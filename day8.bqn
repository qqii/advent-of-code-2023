#!/usr/bin/env cbqn

# Trying out namespaces and control flow today.
# https://mlochbaum.github.io/BQN/doc/namespace.html
# https://mlochbaum.github.io/BQN/spec/system.html#control
# https://mlochbaum.github.io/BQN/doc/control.html

# First and last have been swapped to better match input data where AAA and ZZZ are within the list somewhere.
e1 â† âŸ¨
  "RL"
  ""
  "ZZZ = (ZZZ, ZZZ)"
  "BBB = (DDD, EEE)"
  "CCC = (ZZZ, GGG)"
  "DDD = (DDD, DDD)"
  "EEE = (EEE, EEE)"
  "GGG = (GGG, GGG)"
  "AAA = (BBB, CCC)"
âŸ©
e2 â† âŸ¨
  "LLR"
  ""
  "ZZZ = (ZZZ, ZZZ)"
  "BBB = (AAA, ZZZ)"
  "AAA = (BBB, BBB)"
âŸ©

# Pretty print a block, for debugging purposes
PPrintB â† { (âŠ£â‰Ë˜ğ•©âŠ¸â€¢ns.GetÂ¨) â€¢ns.Keysğ•© }

Parse â† {
  # Help! How do I train?
  ParseNode â† (3âŠ¸â†‘ â‹ˆ ((3âŠ¸â†‘7âŠ¸â†“) â‹ˆ (3âŠ¸â†‘12âŠ¸â†“)))
  pathâ€¿node_map â† (âŠ‘â‹ˆ2âŠ¸â†“) ğ•©
  [nodes, node_dirs] â† â‰>ParseNode Â¨ node_map
  
  path â‡
  startâ€¿end â‡ nodesâŠ"AAA"â€¿"ZZZ"
  [left, right] â‡ nodesâŠâ‰>node_dirs
}
# ğ•¨ is the output of Parse
# ğ•© is a state space { steps, node } for steps taken and current node
Cond â† {
  data â† ğ•¨
  state â† ğ•©
  data.end â‰  state.node
}
Step â† {
  data â† ğ•¨
  state â† ğ•©

  path_ix â† (â‰ data.path)|state.steps
  dir â† âŠ‘path_ixâ†“data.path  

  {
    dir = 'L' ? 
      steps â‡ state.steps + 1
      node â‡ âŠ‘state.nodeâ†“data.left ;
      steps â‡ state.steps + 1
      node â‡ âŠ‘state.nodeâ†“data.right
  }
}
Part1 â† {
  data â† Parse ğ•©
  (data Step â€¢_while_ Cond { steps â‡ 0 â‹„ node â‡ data.start }).steps
}
â€¢Show âŸ¨"Example 1 Part 1", Part1 e1âŸ©
â€¢Show âŸ¨"Example 1 Part 1", Part1 e2âŸ©

e3 â† âŸ¨
  "LR"
  ""
  "11A = (11B, XXX)"
  "11B = (XXX, 11Z)"
  "11Z = (11B, XXX)"
  "22A = (22B, XXX)"
  "22B = (22C, 22C)"
  "22C = (22Z, 22Z)"
  "22Z = (22B, 22B)"
  "XXX = (XXX, XXX)"
âŸ©

# Bah, I could make this take a function ğ•¨ to get the start
ParseA â† {
  # Help! How do I train?
  ParseNode â† (3âŠ¸â†‘ â‹ˆ ((3âŠ¸â†‘7âŠ¸â†“) â‹ˆ (3âŠ¸â†‘12âŠ¸â†“)))
  pathâ€¿node_map â† (âŠ‘â‹ˆ2âŠ¸â†“) ğ•©
  [nodes, node_dirs] â† â‰>ParseNode Â¨ node_map
  
  path â‡
  starts â‡ /'A'=Â¯1âŠ‘Â¨nodes
  ends â‡ /'Z'=Â¯1âŠ‘Â¨nodes
  [left, right] â‡ nodesâŠâ‰>node_dirs 
}
CondZ â† {
  data â† ğ•¨
  state â† ğ•©
  âˆ¨Â´ state.node â· data.ends
}
Part2 â† {
  data â† ParseA ğ•©
  inits â† { steps â‡ 0 â‹„ node â‡ ğ•© }Â¨ data.starts
  each â† (dataâŠ¸(Step â€¢_while_ CondZ))Â¨ inits
}
#{ğ•© â€¢ns.Get "steps"}Â¨
PPrintBÂ¨ Part2 e3

# Part 1 Initial Thoughts:

# The input sequence is heckin' long, as is the number of nodes. There's
# probably a "smarter" algorithm at play here. Parsing this is going to be a
# bitch too. The 2nd example should give me a hint - there's a cycle going on
# there and if I can work out the properties maybe I can figure out a formula
# without having to deal with it.
# One question to consider, is if i'll reaching the end is odne on a multiple of
# the instructions or not.

# After Part 1:

# There's a bit to learn when it comes to namespaces. They seem pretty handy to
# keep things clean but also introduce quite a bit of boilerplate. 
# Not the most keen that my functions that use state before I get a chance to
# define it, and I'm guessing it's all dynamic. 
# It's really quite terse, which explains the desire to have short variable
# names.

# After writing the initial solution I tought it would be quite inefficient.
# Turns out not to be the case. Parsing was also far easier than expected - it's
# a lot eaiser when the data is structured by index and not by arbitary length
# seperators.

# Part 2 Initial Thoughts:

# The difficulty here will really depend on how many nodes end with A. If there are too many then there's probably a trick, but part A was deceptively simple. 

# The simple approach, which may be inefficient is to:

# 1. Find all that ends with A
# 2. Run the loop against each of them
# 3. Calculate the least common multiple between them

# bqn.js doens't support â€¢FLines, but does support â€¢GetLine.
# This snippet was kindly shared with me by funmaker
#input â† 1 â†“ Â¯1 â†“ (âŠ¢ âˆ¾âŸœ< â€¢GetLine)â€¢_while_(@ â‰¢ Â¯1 âŠ‘ âŠ¢) âŸ¨""âŸ©
#input â† â€¢FLines "inputs/day8.txt"
#â€¢Show âŸ¨"Part 1", Part1 inputâŸ© 
#â€¢Show âŸ¨"Part 2", Part2 inputâŸ©